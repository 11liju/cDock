//
//  BlackDock.m
//  BlackDock
//
//  Created by gnz on 13/10/29
//  Edited by w0lf on 14/4/5
//
//  Copyright 2013 cvz. All rights reserved.
//	BlackDock is released under the MIT License.
//	http://opensource.org/licenses/mit-license.php
//

#import "cDock.h"
#import <objc/objc-class.h>
#include <stdlib.h>

void SwizzleInstanceMethod (Class cls, SEL old, SEL new) {
	Method mold = class_getInstanceMethod(cls, old);
	Method mnew = class_getInstanceMethod(cls, new);
	if (mold && mnew) {
		if (class_addMethod(cls, old, method_getImplementation(mold), method_getTypeEncoding(mold))) {
			mold = class_getInstanceMethod(cls, old);
		}
		if (class_addMethod(cls, new, method_getImplementation(mnew), method_getTypeEncoding(mnew))) {
			mnew = class_getInstanceMethod(cls, new);
		}
		method_exchangeImplementations(mold, mnew);
	}
}

@interface BlackDockSeparatorLayer : CALayer
{
	
}

@end

@implementation BlackDockSeparatorLayer

+ (id)layer
{
	CALayer *layer = [super layer];
	layer.contents = [NSImage imageNamed:@"vertical"];
	layer.contentsGravity = kCAGravityResizeAspect;
	
	return layer;
}

- (void)resizeWithOldSuperlayerSize:(CGSize)size
{
    CGRect rect = self.superlayer.frame;
    //trash bin adjustment -- Nero Wolfe
	rect.origin.x = 2;
	rect.origin.y *= -1;
	CALayer *floorLayer = [[BlackDock sharedInstance] floorLayer];
	rect.size.height = [floorLayer frame].size.height - floorLayer.cornerRadius;
	
	self.frame = rect;
}

@end

@interface BlackDockFloorLayer : CALayer
{
	
}

@end

@implementation BlackDockFloorLayer

- (void)resizeWithOldSuperlayerSize:(CGSize)size
{
//    NSArray *paths = NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES);
//    NSString *docDir = [paths objectAtIndex:0];
//    NSString *docFile = [NSString stringWithFormat:@"%@/Application Support/cDock/dock_settings.txt", docDir];
//    NSString *contents = [NSString stringWithContentsOfFile:docFile encoding:NSUTF8StringEncoding error:NULL];
//    NSArray *lines = [contents componentsSeparatedByCharactersInSet:[NSCharacterSet newlineCharacterSet]];
//    
//    CGFloat rhm, hda, rws;
    
	CALayer *layer = self.superlayer;
	if (layer) {
		NSInteger orientation;
		if (object_getInstanceVariable(layer, "_orientation", (void **)&orientation)) {
			// 0:bottom, 1:left, 2:right
			CGRect rect = layer.bounds;
			if (orientation == 0) {
                rect.size.height *= 1.75; //1.65
                rect.size.height += self.cornerRadius;
                rect.size.height += self.borderWidth * 2;
                
                if (self.cornerRadius == 0)
                {
                    rect.size.height += 2;
                }
                
                //rect.size.width += -18.00;
				rect.size.width += self.borderWidth * 2;
				
                rect.origin.y -= self.borderWidth;
                rect.origin.y -= self.cornerRadius;
                
                rect.origin.x -= self.borderWidth;
                rect.origin.x += 2;
                //rect.origin.x += 10;
			} else {
                rect.size.width += self.cornerRadius;
                rect.size.width += 50;
                
                //Left
                if (orientation == 1) {
					rect.origin.x -= self.cornerRadius;
                    //rect.origin.x -= 50;
                    rect.origin.y -= 50;
				} else {
                    rect.origin.x -= 50;
                    rect.origin.y += 50;
                }
			}
            
//            if (orientation == 0) {
//                // Dock positioning fix -- Nero Wolfe
//                rect.size.height *= 1.75; //1.65
//                rect.size.height += self.cornerRadius;
//                rect.size.width += -18.00;
//				//rect.size.width += self.cornerRadius;
//				rect.origin.y -= 4; //self.cornerRadius;
//                rect.origin.x += 10;
//			} else {
//				rect.size.width += self.cornerRadius;
//				if (orientation == 1) {
//					rect.origin.x -= self.cornerRadius;
//				}
//			}
			
			self.frame = rect;
			
		}
	}
}

+ (id)layer
{
// Taco salad here!
    
    CALayer *layer = [super layer];
    CGColorRef color;
    CGFloat rBack, bBack, gBack, aBack, rBord, bBord, gBord, aBord;
    CGFloat cRad, bWid, sRad, sOpa;
    
    NSArray *paths = NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES);
    NSString *docDir = [paths objectAtIndex:0];
    NSString *docFile = [NSString stringWithFormat:@"%@/Application Support/cDock/dock_settings.txt", docDir];
    NSString *contents = [NSString stringWithContentsOfFile:docFile encoding:NSUTF8StringEncoding error:NULL];
    NSArray *lines = [contents componentsSeparatedByCharactersInSet:[NSCharacterSet newlineCharacterSet]];
    
    rBack = ([lines[0] integerValue] / 255.);
    gBack = ([lines[1] integerValue] / 255.);
    bBack = ([lines[2] integerValue] / 255.);
    aBack = ([lines[3] integerValue] / 100.);
    
    rBord = ([lines[4] integerValue] / 255.);
    gBord = ([lines[5] integerValue] / 255.);
    bBord = ([lines[6] integerValue] / 255.);
    aBord = ([lines[7] integerValue] / 100.);
    
    cRad = ([lines[8] integerValue] / 1.);
    bWid = ([lines[9] integerValue] / 1.);
    sRad = ([lines[10] integerValue] / 1.);
    sOpa = ([lines[11] integerValue] / 100.);
    
    //    for (NSString *line in lines) {
    //        NSInteger currentInteger = [line integerValue];
    //        rBack = (currentInteger / 255.);
    //        // Do something with the integer.
    //    }
    
// How 2 DEBUG? I dunno print values to text file?
    
    //    NSString *doc1File = [NSString stringWithFormat:@"%@/pootis.txt", docDir];
    //    NSString *doc2File = [NSString stringWithFormat:@"%@/pootis1.txt", docDir];
    //    NSString *myoutPut = [NSString stringWithFormat:@"%g", rBack];
    //    [docDir writeToFile:doc1File atomically:YES encoding:NSUTF8StringEncoding error:NULL];
    //    NSInteger abc = [lines[0] integerValue];
    //    myoutPut = [NSString stringWithFormat:@"%ld", (long)abc];
    //    [myoutPut writeToFile:doc2File atomically:YES encoding:NSUTF8StringEncoding error:NULL];
    
// Mmm crunchy

	
// Corner radius:
    layer.cornerRadius = cRad;
    
// Random colors:
    // CGFloat r = ( arc4random() % 255 / 255. );  //  0.0 to 1.0
    // CGFloat g = ( arc4random() % 255 / 255. );  //  0.0 to 1.0
    // CGFloat b = ( arc4random() % 255 / 255. );  //  0.0 to 1.0
    
// Background
    color = CGColorCreateGenericRGB(rBack, gBack, bBack, aBack);
    layer.backgroundColor = color;
	CGColorRelease(color);
    
// Border
    color = CGColorCreateGenericRGB(rBord, gBord, bBord, aBord);
    layer.borderColor = color;
	CGColorRelease(color);
	
// Width of border:
    layer.borderWidth = bWid;
    
// Shadows:
    layer.masksToBounds = NO;
    layer.shadowOffset = CGSizeMake(0, 0);
    layer.shadowRadius = sRad;
    layer.shadowOpacity = sOpa;
    
	return layer;
}

@end

@implementation NSObject (BlackDock)

- (void)BlackDock_DOCKTileLayer_createShadowAndReflectionLayers
{
	//do nothing
}

- (void)BlackDock_DOCKFloorLayer_setGlobalSeparatorPosition:(double)arg1
{
	[self BlackDock_DOCKFloorLayer_setGlobalSeparatorPosition:arg1];
	
	Class cls = NSClassFromString(@"DOCKFloorLayer");
	SEL old = @selector(setGlobalSeparatorPosition:);
	SEL new = @selector(BlackDock_DOCKFloorLayer_setGlobalSeparatorPosition:);
	SwizzleInstanceMethod(cls, old, new);
	
	BlackDock *blackDock = [BlackDock sharedInstance];
	if (!blackDock.rootLayer) {
		blackDock.rootLayer = [(id)self superlayer];
		[blackDock performSelectorOnMainThread:@selector(setUp) withObject:nil waitUntilDone:NO];
	}
}

@end

@implementation BlackDock

@synthesize rootLayer;
@synthesize floorLayer;
@synthesize separatorLayer;

+ (void)load
{
	Class cls = NSClassFromString(@"DOCKFloorLayer");
	SEL old = @selector(setGlobalSeparatorPosition:);
	SEL new = @selector(BlackDock_DOCKFloorLayer_setGlobalSeparatorPosition:);
	SwizzleInstanceMethod(cls, old, new);
	
	cls = NSClassFromString(@"DOCKPreferences");
	id dockPref = nil;
	SEL aSel = @selector(preferences);
	if ([cls respondsToSelector:aSel]) {
		dockPref = [cls performSelector:aSel];
	}
	if (dockPref) {
		NSString *key = @"showProcessIndicatorsPref";
		id val = [dockPref valueForKey:key];
		if (val) {
			[dockPref setValue:[NSNumber numberWithBool:![val boolValue]] forKey:key];
			[dockPref setValue:val forKey:key];
		}
	}
}

+ (BlackDock *)sharedInstance
{
	static BlackDock *blackDock = nil;
	if (!blackDock) {
		blackDock = [self new];
		[[NSUserDefaults standardUserDefaults] addObserver:blackDock forKeyPath:@"orientation" options:NSKeyValueObservingOptionNew context:nil];
	}
	
	return blackDock;
}

- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context
{
	if ([keyPath isEqualToString:@"orientation"]) {
		if (self.floorLayer.superlayer) {
			[self.floorLayer resizeWithOldSuperlayerSize:CGSizeZero];
		} else {
			[self setUp];
		}
	}
}

- (void)setUp
{
	CALayer *layer = self.rootLayer;
	NSArray *arr = layer.sublayers;
	if (!self.floorLayer) {
		self.floorLayer = [BlackDockFloorLayer layer];
		self.separatorLayer = [BlackDockSeparatorLayer layer];
		
		SEL aSel = @selector(removeShadowAndReflectionLayers);
		NSArray *tileLayers = [arr filteredArrayUsingPredicate:[NSPredicate predicateWithBlock:^(id evaluatedObject, NSDictionary *bindings) {
			return [evaluatedObject respondsToSelector:aSel];
		}]];
		[tileLayers makeObjectsPerformSelector:aSel];
		arr = layer.sublayers;
		
		Class cls = NSClassFromString(@"DOCKTileLayer");
		SEL old = @selector(createShadowAndReflectionLayers);
		SEL new = @selector(BlackDock_DOCKTileLayer_createShadowAndReflectionLayers);
		SwizzleInstanceMethod(cls, old, new);
	}
	Class dockFloorLayer = NSClassFromString(@"DOCKFloorLayer");
	for (layer in arr) {
		if ([layer isKindOfClass:dockFloorLayer]) {
			break;
		}
	}
	if (layer) {
		BOOL flag;
		if (object_getInstanceVariable(layer, "_dontEverShowMirror", (void **)&flag)) {
			if (!flag) {
				object_setInstanceVariable(layer, "_dontEverShowMirror", (void *)YES);
				SEL aSel = @selector(turnMirrorOff);
				if ([layer respondsToSelector:aSel]) {
					[layer performSelector:aSel];
					
					[layer addSublayer:self.floorLayer];
					[self.floorLayer resizeWithOldSuperlayerSize:CGSizeZero];
					
					NSInteger orientation;
					if (object_getInstanceVariable(layer, "_orientation", (void **)&orientation)) {
						// 0:bottom, 1:left, 2:right
						if (orientation == 0) {
							CALayer *separator;
							if (object_getInstanceVariable(layer, "_separatorLayer", (void **)&separator)) {
								[separator addSublayer:self.separatorLayer];
								[self.separatorLayer resizeWithOldSuperlayerSize:CGSizeZero];
								separator.contents = nil;
							}
						}
					}
				}
			}
		}
	}
}

@end
